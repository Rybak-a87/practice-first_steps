import PythonFromScratch.PythonFromScratch as pfs
import ObjectOrientedProgramming.ObjectOrientedProgramming as oop


# ============================================================
#       **********         **********        **********      =
#       ***    ***         ***               ***             =
#       ***    ***         ****              ***             =
#       **********         **********        **********      =
#       ***                ***                      ***      =
#       ***                ***               **********      =
# ============================================================

# Урок 7 (Python с нуля) (работа со строками)
# pfs.prac7_1() # подсчет букв "а"
# pfs.prac7_1v2() # подсчет букв "а" (с помощью метода)
# pfs.prac7_2() # удаление всех сочетаний "ab"
# pfs.prac7_2v2() # удаление всех сочетаний "ab" (с помощью метода)
# pfs.prac7_3() # определение слова палиндром
# pfs.prac7_4() # определение колличества фраз "ra"
# pfs.prac7_4v2() # определение колличества фраз "ra" (с помощью метода)
# pfs.prac7_5() # разделения предложения на слова
# pfs.prac7_5v2() # разделения предложения на слова 2й способ (с помощью метода)


# Урок 8 (Python с нуля) (методы строк)
# pfs.prac8_1() # корректный ввод номера телефона по шаблону х(ххх)хххххх
# pfs.prac8_2() # в строку "2+3+6.7 + 82 + 5.7 +1" заменить + на - и удалить все пробелы
# pfs.prac8_3() # вывести числа 0; -100; 5.6; -3 в виде столбца по правому краю
# pfs.prac8_4() # в строке "abrakadabra" найти "ra" и вывести их индексы


# Урок 9 (Python с нуля) (списки и функции)
# pfs.prac9_1() # увеличить каждый элемент списка [-1, 0, 5, 3, 2] на 7.2
# pfs.prac9_2() # пользователь вводит значения, на их основе сформировать список состоящий из продублированных значений
# pfs.prac9_3() # сложить две матрицы
# pfs.prac9_4() # пользователь вводит значения в список, в нем проверить была ли введена циара 5


# Урок 10 (Python с нуля) (списки, срезы и методы)
# pfs.prac10_1() # пользователь вводит числа, до тех пор пока не введен 0. Все введенные числа возводятся в квадрат и помещаются в список
# pfs.prac10_2() # удалять из списка ["+7912123456", "+715213456", "+6915213456", "+4915213456", "+7915213456"] номера на +7
# pfs.prac10_3() # сдвигает любой элемент списка в начало или конец списка (2 способа: цикл и методы)


#Урок 12 (Python с нуля) (словари, их методы)
# pfs.prac12_1() # вводим произвольные целые числа, ключами будут только четное числа, а значениями - квадраты этих чисел
# pfs.prac12_2() # из строки "int=целое число, dict=словарь, list=список, str=строка, bool=булевый тип" сделать словарь
# pfs.prac12_3() # переводчик - английское слово (ключ), руссное (значение)


#Урок 13 (Python с нуля) (Кортежи и операции с ними)
# pfs.prac13_1() # дан кортеж ("+792345678", "+792345478", "+792355678", "+592345678", "+392345678", "+7923456558") вывести все номера на +7
# pfs.prac13_2() # есть строка "Оценки: 5, 4, 3, 4, 2, 4, 5, 4" создать кортеж только с оценок в виде целых чисел
# pfs.prac13_3() # вывести значение кортежа ((1,2,3)(4,5,6)(7,8,9)) в виде таблицы 1 - 2 - 3 и т.д.


'''Урок 16 (Рекурсивные и лямбда-функции, функции с произвольным числом аргументов)
1. Написать рекурсивную функцию для вычисления факториала числа n: n != 1*2*3*...*n
2. Написать функцию для вычисления среднего арифметического переданных ей значений 
    в виде аргументов: arg1, arg2, ...,argN
3. Реализовать функцию сортировки выбранных элементов по возрастанию: элементы передают 
    функции в виде списка и и выбираются они с помощью функции-селектора, указанной в 
    качестве второго параметра. Привести примеры вызова функции сортировки с разными 
    видами селекторов. Селекторы реализовать в виде лямбда-функции.
'''


# pfs.prac16_1()
# pfs.prac16_2()
# pfs.prac16_3sort()
# pfs.prac16_3max()


'''Урок 17 (Алгоритм Евклида, принцип тестирования программ)
1. Реализовать последний вариант алгоритма Евклида с помощью рекурсивной функции.
2. Написать функцию нахождения максимального значения среди переданных аргументов: arg1, arg2, ...,argN
3. Реализовать универсальную функцию для нахождения максимального и минимального значения среди: arg1, arg2, ...,argN
    с помощью функцию-селектора, указанной в виде лямбда-функции как один из параметров функции поиска.
'''


# pfs.prac17_1()
# pfs.prac17_2()
# pfs.prac17_3()


'''Урок 19 (Множества (set) и операции над ними - вычитание, пересечение, объединение, сравнение)
Напишите программу, которая из введенного с клавиатуры текста определяет число 
    уникальных слов. Для простоты можно полагать, что слова разделяются пробелом или 
    символом переноса строки '\n'
'''


# pfs.prac19_1()


'''Урок 20 (Итераторы, выражения-генераторы, функции-генераторы, оператор yield)
Пусть дан текст:
    t = ("""Генератор - это итератор, элементы которого
    можно перебирать (итерировать) только один раз.
    Итератор - это объект, который поддерживает функцию next()
    для перехода к следующему элементу коллекции.""")
Написать функцию-генератор для выделения слов из этого текста (слова разделяются 
пробелом или символом переноса строки '\n'). Список всех слов при этом в функции не создавать.
'''


# pfs.prac20_1()


'''Урок 21 (Функции map, filter, zip)
1. Поставить в соответствии соответствующим английским символам русские буквы: 
    h - х, e - е, l - л, o - о, w - в, r - р, d - д
    и преобразовать строку: "hello world!"
    в русские символы.
2.Дан текст:
    t = """Куда ты скачешь гордый конь,
    И где опустишь ты копыта?
    О мощный властелин судьбы!
    Не так ли ты над самой бездной,
    На высоте, уздой железной
    Россию поднял на дыбы?"""
    Необходимо выделить каждое второе слово из этого стихотворения и представить результат в виде 
    упорядоченного списка. (Подумайте как реализовать алгоритм с наименьшими затратами по памяти).
3.Реализовать алгоритм для нахождения всех делителей натурального числа N. Число N вводится с 
    клавиатуры. Для начала можно реализовать простым перебором всех N возможных чисел (делителей). 
    Затем подумайте, как можно оптимизировать по скорости этот алгоритм.
'''


# pfs.prac21_1()
# pfs.prac21_2()


'''Урок 22 (Сортировка sort() и sorted(), сортировка по ключам)
1. Используя сортировку, найдите первые три наименьшие значения в списке: a = [1, 2, -5, 0, 5, 10]
    Сам список должен оставаться неизменным.
2. Отсортируйте список: digs = (-10, 0, 7, -2, 3, 6, -8)
    так, чтобы сначала шли отрицательные числа, а затем положительные.
3. Пусть имеется словарь: {"+7": 23445678901, "+4": 3456789012, "+5": 5678901234, "+12": 78901234}
    Необходимо вывести телефонные номера по убыванию чисел, указанных в ключах, то есть по порядку: +4, +5, +7, +12
'''


# pfs.prac22_1()
# pfs.prac22_2()
# pfs.prac22_3()


'''Урок 23 (Обработка исключений - try, except, finally, else)
1. Напишите программу ввода натуральных чисел через запятую и преобразования этой строки в список 
    целых чисел. (Используйте здесь функцию map для преобразования элементов последовательности строк 
    в последовательность чисел). Реализовать обработку возможных исключений при таком преобразовании.
2. Написать функцию вычисления среднего арифметического элементов переданного ей списка. Реализовать 
    обработку возможных исключений при её работе.
3. Написать функцию-генератор (с использованием оператора yield) для удаления произвольного элемента 
    из множества (с помощью метода pop()). Функция должна возвращать значение удалённого элемента. 
    Реализовать обработку возможных исключений при ее работе.
'''


# pfs.prac23_1_2_3()


'''Урок 24 (Файлы - чтение и запись - open, read, write, seek, readline, dump, load, pickle)
1. Выполнить считывание данных из текстового файла через символ и записи прочитанных данных в другой текстовый файл.
    Прочитывайте там не более 100 символов.
2. Пользователь вводит предложение с клавиатуры. Разберите это предложение по словам (считать, что 
    слова разделены пробелами) и сохранить их в столбец в файл.
3. Пусть имеется словарь:
    d = {"house": "дом", "car": "машина",
    "tree": "дерево", "road": "дорога",
    "river": "река"}
    Необходимо каждый элемент этого словаря сохранить в бинарном файле как объект. Затем, прочитать этот 
    файл и вывести считанные объекты в консоль.
'''


# pfs.prac24_1()
# pfs.prac24_2()
# pfs.prac24_3()


'''Урок 25 (Форматирование строк - метод format и F-строки)
1. Пользователь через пробел вводит ФИО. На основе этой информации требуется создать строку с сообщением:
    Ваши персональные данные:
    Фамилия: введенная фамилия
    Имя: введенное имя
    Отчество: введенное отчество
2. Имеется текстовый файл с содержимым:
    Иван, ivan@gm.com, 18
    Татьяна, tat@gm.com, 22
    Сергей, srg@gm.com, 33
    Федор, fr@gm.com, 41
    Елена, el@gm.com, 27
    Необходимо построчно считывать информацию и для каждой строки для лиц не старше 30 лет сформировать сообщение:
    Уважаемый(ая) <имя>! Приглашаем Вас принять участие в курсах по изучению Python. 
    Подробную информацию мы выслали на email: <email>.
'''


# pfs.prac25_1()
# pfs.prac25_2()


'''Урок 26 (Создание и импорт модулей - import, from, as, dir, reload)
1. Задайте в модуле словарь, в котором ключами являются английские слова, а значение соответствующее 
    русские (перевод). Также добавьте необходимые функции для добавления и удаления новых слов в этом 
    словаре. Импортируйте этот модуль в основную программу и реализуйте мини-словарь со следующим меню (функционалом):
    (1) Перевести слово
    (2) Добавить слово
    (3) Удалить слово
    (4) Завершить работу
2. Попробуйте развить идею словаря и добавьте возможность автоматического сохранения и считывания данных из
    файла (в файле сохраняется словарь целиком).
'''


# pfs.prac26_1()


'''Урок 28 (Декораторы функций и замыкания)
1. Напишите две функции создания списка из четных чисел от 0 до N (N - аргумент функции): [0, 2, 4, ..., N]
    с помощью метода append и с помощью инструмента list comprehensions (генератор списков).
    Через декоратор определите время работы этих функций.
2. Напишите декоратор для кэширования результатов работы функции вычисления квадратного 
    корня положительного целочисленного значения x. То есть, при повторном вызове функции (через декоратор) 
    с одним и тем же аргументом, результат должен браться из кэша, а не вычисляться заново. (Подсказка: 
    здесь следует использовать замыкание для хранения кэша).
'''


# pfs.prac28_1()
# pfs.prac28_2()


# ============================================================
#       *********        *********        **********         =
#       ***   ***        ***   ***        ***    ***         =
#       ***   ***        ***   ***        ***    ***         =
#       ***   ***        ***   ***        **********         =
#       ***   ***        ***   ***        ***                =
#       *********        *********        ***                =
# ============================================================


# oop.prac_1()


# oop.prac_2_1_2()
# oop.prac_2_3()


'''Урок 4 (Свойства (property) и дескрипторы классов)
1. Объявите класс Calendar для хранения данных: даты, месяц, год. Определите 
    свойства для записи и считывания этой информации из этого класса. 
    (ДОПОЛНЕНИЕ: используя __slots__ разрешите использовать только строго определенные 
    локальные свойства в экземплярах класса)
2. Объявите класс Rectangle, хранящий координаты верхней левой точки. Создайте дескрипторы 
    для записи и считывания этих значений в классе (атрибуты с данными координат должны быть приватными)
'''


# oop.prac_4_1()
# oop.prac_4_2()


'''Урок 5 (Статические методы и свойства класса)
1. Объявите класс Rectangle (прямоугольник), в котором имеется статический метод, 
    вычисляющий площадь прямоугольника. Этот метод принимает два параметра (ширину и длину), 
    вызывается в конструкторе для вычисления площади конкретного прямоугольника и результат 
    присваивается локальному свойству создаваемого экземпляра класса.
2. Создайте класс Dog (собака), в каждом его экземпляре создавайте несколько локальных свойств 
    (например: имя, возраст, порода) и сделайте так, чтобы можно было создать не более пяти экземпляров этого класса.
'''


# oop.prac_5_1()
# oop.prac_5_2()#?????


'''Урок 6 (Простое наследование классов)
1.Создайте суперкласс "Персональные компьютеры" и на его основе подклассы: "Настольный ПК" и "Ноутбуки". 
    В базовом классе определите общие свойства: размер памяти, диска, модель, CPU. А в производных 
    классах уникальные свойства:
- для настольных: монитор, клавиатура, мышь, их габариты. И метод для вызова этой информации в консоль.
- для ноутбука: габариты, диагональ экрана. И метод для вызова этой информации в консоль.
2. Повторите это задание для суперкласса "Человек" и подклассов "Мужчина" и "Женщина". Подумайте 
    какие общие характеристики можно выделить в суперкласс и какие частные свойства указать в подклассах.
'''


# oop.prac_6_1()
# oop.prac_6_2()


"""Урок 7 (Переопределение и перегрузка методов)
1. Создайте базовый класс "Стол" и дочерний: "Прямоугольные столы" и "Круглые столы". 
    Через конструктор базового класса передайте размер поверхности стола: для прямоугольного - 
    ширина и длинна, для круглого радиус. В дочерних классах реализуйте метод вычисления площади поверхности стола.
2. Создайте класс Animal (животные) и разные производные от него подклассы: Fox, Bird, Cat, Dog и т.д. 
    Реализуйте у них общий метод say(), который бы возвращал звук, издаваемый этим животным. 
    Создайте кортеж из нескольких этих экземпляров классов, переберите их в цикле и выведите в 
    консоль их звуки (вызовите метод say()).
"""


# oop.prac_7_1()
# oop.prac_7_2()


"""Урок 8 (Множественное наследование)
Создайте дочерний класс Motherboard (материнская плата), которая
    наследуется от классов: CPU (процессор), GPU (графический 
    сопроцессор), Memory (память). В свою очередь CPU наследуется от 
    классов: AMD и Intel, GPU от классов NVidia и GeForce.
Создайте экземпляр класса Matherboard и наполните ее конкретным
    содержимым (локальным свойствам этого объекта присвойте 
    определенные значения). Определите вспомогательные методы в базовых
    классах и выведите итоговую информацию в консоль с помощью метода 
    showInfo() класса Matherboard.
"""


# oop.prac_8_1()
# oop.prac_8_2()


"""Урок 9 (Перегрузка операторов)
1. Напишите класс Paint3D для хранения координат в трехмерном 
    пространстве (x, y, z). Реализуйте перегрузку операторов сложения,
    вычитания, умножения и деления для этого класса. Также сделайте
    возможность сравнения координат между собой и запись-считывание
    значений через ключи: "x", "y", "z".
2. Напишите класс Matrix для работы с матрицами. Реализуйте перегрузку
    операторов сложения и вычитания для матриц разных размеров.
    Перегрузите оператор умножения для матриц, которые могут быть 
    перемножены. Также сделайте возможность сравнения матриц между 
    собой (на равенство и неравенство).
3. Напишите класс Complex для работы с комплексными числами. Реализуйте
    операторы сложения, вычитания и умножения. Также сделайте 
    возможность присвоения действительных и мнимых значений через ключи
    <rel> и <img> и через свойства rel, img, реализованных с помощью
    дескрипторов.
"""


# oop.prac_9_1()
# oop.prac_9_2()
# oop.prac_9_3()


"""Урок 10 (Пример собственных исключений и итераторов)
1. Измените класс Image так, чтобы в нем появился метод resize(width, heigth). Если новая 
    ширина или высота меньше текущего значения, все цвета, оказавшиеся за пределами новых 
    границ изображения, должны удаляться. Если в качестве нового значения ширины или высоты 
    передается None, соответствующее значение ширины или высоты должно оставаться без изменений.
2. Реализуйте класс ListInt для хранения списка целых чисел и сделайте его итерируемым так, 
    чтобы значения возвращались с конца в начало.
3. Создайте класс Persons для хранения списка уникальных посетителей клуба. Сделайте 
    возможность перебора гостей итератором(ми) следующим образом:
- с выводом только их имен
- с выводом только их возраста
- с выводом только их фамилии
"""


# oop.prac_10_1()
# oop.prac_10_2()
# oop.prac_10_3()


"""Урок 11 (Функторы и менеджеры контекстов)
1. Создайте функтор для определения порядка сортировки списка p, состоящий из объектов класса Person:
class Person:
    def __init__(self, surname, forename, old):
        self.forename = forename
        self.surname = surname
        self.old = old
p = [Person("Иванов", "Иван", 20),
     Person("Петров", "Степан", 21),
     Person("Сидоров", "Альберт", 25)]
То есть, вызывая функцию (пусть он называется SortKey) с названием поля SortKey("surname"), 
    сортировка выполнялась бы по этому свойству. Если указать сразу два значения: SortKey("surname", "forname"), 
    то сортировка делалась бы по фамилии, но при их равенстве - по имени.
(Подсказка: используйте метод sort списка p и его именованный параметр key).
2. Создайте менеджер контекста для безопасной обработки элементов словаря. В случае возникновения 
    исключения словарь должен оставаться без изменений. Иначе (при успешной работе) он сохранял бы все изменения.
"""


# oop.prac_11_1()
# oop.prac_11_2()

