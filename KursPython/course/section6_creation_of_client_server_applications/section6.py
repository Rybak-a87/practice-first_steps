# Создание клиент-серверных приложений


import requests
import bs4
import socket
import http.server


# --------------------------------------------------------
"""Раздел 6 (1 Чтение данных с сайта)
1) Создайте словарь, где ключами будут названия телефонов из урока, а значениями будут их цены.
2) Выведите его в консоль, чтобы убедиться, что всё правильно.
Примечание: разумеется, цены этих телефонов надо вытащить с сайта, используя показанные в
    уроке инструменты для парсинга.
"""


def lesson_1():
    # !URL сайта с которым работаем
    url = "https://allo.ua/ua/products/mobile/klass-kommunikator_smartfon/"
    # !получение данных с сайта в виде кода
    rq = requests.get(url)
    rq.encoding = "utf-8"
    # !обработка полученного ранее кода с сайта
    bs = bs4.BeautifulSoup(rq.text, "html.parser")
    # !сбор необходимой информации с сайта
    produсt_name = bs.select("div.product-card__content a.product-card__title")
    produсt_price = bs.select("div.v-price-box__cur span.sum")
    result = dict()
    # !добавление в словарь полученной информации
    for i in range(len(produсt_name)):
        result.setdefault(produсt_name[i].getText(), produсt_price[i].getText())
    # !вывод в консоль элесенты словаря
    print("Популярные телефоны АЛЛО:\n")
    for i in result.items():
        print(f"{i[0]} - цена: {i[1]} грн.")
        print(f"{'-' * 60}")


# --------------------------------------------------------
""" Раздел 6 (2 Создание серверной части)
1) Создайте сервер, который получает число, умножает его на 10 и отправляет обратно клиенту.
2) При получении команды «stop», сервер должен быть остановлен (в примере из урока это можно
    сделать, завершив бесконечный цикл с помощью break).
"""


def lesson_2():
    # !адрес сервера и порт
    SERVER_ADDRESS = ("", 56009)
    # !создаем сервер
    server = socket.socket()
    # !привязка сервера к адресу
    server.bind(SERVER_ADDRESS)
    # !определяем максимальное количество клиентов для одновременного пользования сервером
    server.listen(1)
    # !цикл ожидания подключения
    while True:
        # !информация полученая от клиента приоброзована к переменным
        a, b = server.accept()
        # !получение данных с полученной информации с указанием кол-ва байт информации
        from_user = a.recv(4096)
        print("Получено от пользователя:", from_user)
        # !обработка полученных данных
        if from_user.decode("utf-8") == "stop":
            print("Сервер остановлен")
            break
        # !проверка является ли строка от пользователя числом
        if from_user.decode("utf-8").isdigit():
            for_user = bytes(f"{int(from_user.decode('utf-8')) * 10}", encoding="utf-8")
        else:
            for_user = bytes(f"{from_user.decode('utf-8')} не число", encoding="utf-8")
        # !отправка ответа клиенту
        a.send(for_user)
        # !отключение клиента от сервера (рассоеденение)
        a.close()


# --------------------------------------------------------
""" Раздел 6 (3 Создание коиентской части)
1) Создайте клиента, который отправляет серверу из предыдущего упражнения число 5, затем ещё
    число 10 и затем команду «exit».
2) Убедитесь, что всё работает правильно, то есть сервер после первой команды должен прислать
    «50», после второй – «100», а после команды «exit» должен быть остановлен (то есть
    программа из предыдущего упражнения должна остановиться).
"""


def lesson_3():
    # !адрес сервера к которому подключатся
    SERVER_ADDRESS = ("localhost", 56009)
    # !создание обьекта (клиент)
    client = socket.socket()
    # !подключение к серверу
    client.connect(SERVER_ADDRESS)
    # !отправка на сервер информацию в байтах с указанием кодировки
    client.send(bytes("5", encoding="utf-8"))
    # client.send(bytes("10", encoding="utf-8"))
    # client.send(b"stop")
    # !получение ответа от сервера
    from_server = client.recv(4096)
    # !выводим полученую декодированную информацию от сервра
    client.close()
    print(from_server.decode("UTF-8"))


# --------------------------------------------------------
""" Раздел 6 (4 Создание Web - страницы)
1) Запустите сервер с помощью Python, чтобы можно было открывать Web-страницы в браузере через localhost.
2) Создайте страницу, на которой выведите HTML-код какой-нибудь реально существующей Web-страницы.
Примечание: тут Вам поможет вывод многострочной строки с помощью ‘’’строка’’’ или “””строка”””.
    Саму страницу выберите любую, которую найдёте в Интернете, откройте исходник (с помощью Ctrl+U) и
    скопируйте оттуда весь код. Обратите внимание, что велика вероятность того, что внешний вид страницы
    будет странным (например, нарушится вёрстка или исчезнут некоторые изображения), это является
    нормальным. Главное, чтобы хоть что-то открылось.
"""


def lesson_4():
    # !создание сервера
    ADDRESS_SERVER = ("", 6123)
    my_local_server = http.server.HTTPServer(ADDRESS_SERVER, http.server.CGIHTTPRequestHandler)
    # !запуск сервера
    my_local_server.serve_forever()


# --------------------------------------------------------
""" Раздел 6 (5 Обработка форм)
1) Создайте простую форму с заголовком «Авторизация», полями «Логин» и «Пароль» и кнопкой «Войти».
2) Примите данные из формы, и если логин был «Admin», а пароль «123», то вместо формы вывести
    заголовок: «Здравствуйте, Admin!».
3) Если логин и/или пароль введены другие, то сразу под заголовком у формы написать:
    «Неверные логин и/или пароль».
"""


# --------------------------------------------------------
""" Раздел 6 (6 Работа с cookie)
1) Доработайте предыдущее упражнение, чтобы, если пользователь уже успешно вошёл, то при обновлении
    страницы ему всегда писалось: «Здравствуйте, Admin!».
2) Добавьте ссылку выхода, например, такую: «index.py?logout=1», которую обработайте так, чтобы
    cookie поменялись на пустые значения. Таким образом, после этого снова должна появиться форма входа.
3) Сделайте так, чтобы ссылка выхода была только, если пользователь авторизован.
Примечание: небезопасно хранить открытый пароль в cookie, поэтому как дополнительное задание, используя
    справочник, найдите функцию, которая будет хэшировать пароль (например, через алгоритм md5). Дальше
    храните в cookie уже хэшированный пароль, и сравнивать уже его надо будет не со строкой «123», а также
    с результатом хэширования этой строки.
"""


# --------------------------------------------------------

